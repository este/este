# Prisma does not support interfaces nor union types yet, so we emulate it.
# Soon: https://github.com/prisma/prisma/issues/3408
# https://www.prisma.io/docs/data-model-and-migrations/data-model-knul/#more-sdl-features
# TODO: Use custom scalars instead of Int and Float, e.g. 0-256, 0-1, etc.
# As for tree structure, we use parent/children because it's the most
# straightforward approach for now. We don't need recursive queries because we
# can fetch all related objects from App and resolve them in the client.
# Parents and children are enforced with referential integrity. In the future,
# I'd like to try closure tables, but Prisma doesn't support composite keys yet.
# So, it can be improved ofc but it's good enough for now.
# TODO: Detect parent/child circular references. Maybe closure tables prevent them.
# https://datubaze.files.wordpress.com/2016/03/celkos-trees-and-hierarchies-in-sql_2004.pdf
# https://coderwall.com/p/lixing/closure-tables-for-browsing-trees-in-sql

type User {
  # Props order: ID, own IDs, foreign IDs, scalars.
  id: ID! @unique
  webs: [Web!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String! @unique
  password: String!
  themeName: String
  components: [Component!]! @relation(name: "UserComponents")
}

type Web {
  id: ID! @unique
  creator: User!
  pages: [Page!]! @relation(name: "WebPages", onDelete: CASCADE)
  elements: [Element!]! @relation(name: "WebElements", onDelete: CASCADE)
  styles: [Style!]! @relation(name: "WebStyles", onDelete: CASCADE)
  dimensionValues: [DimensionValue!]!
    @relation(name: "WebDimensionValues", onDelete: CASCADE)
  colorValues: [ColorValue!]!
    @relation(name: "WebColorValues", onDelete: CASCADE)
  borderValues: [BorderValue!]!
    @relation(name: "WebBorderValues", onDelete: CASCADE)
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
}

type Page {
  id: ID! @unique
  creator: User!
  web: Web! @relation(name: "WebPages")
  element: Element!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
}

type Element {
  id: ID! @unique
  type: ElementType!
  index: Int!
  web: Web! @relation(name: "WebElements")
  parent: Element @relation(name: "ElementTree")
  # if type == 'TEXT'
  # Slate text model with bold and italic marks only. Example:
  # [{ text: 'Hello ' }, { text: 'World', marks: [{ type: 'bold' }] }];
  textLeaves: Json
  # else
  children: [Element!]! @relation(name: "ElementTree")
  # children or shared, not both.
  shared: SharedElement @relation(name: "ElementShared")
  # Will get shared || children as children prop.
  component: Component! @relation(name: "ElementComponents")
  props: [ElementProp!]! @relation(name: "ElementProps", onDelete: CASCADE)
}

# Slate model
enum ElementType {
  BLOCK
  INLINE
  TEXT
}

type SharedElement {
  id: ID! @unique
  sharedBy: [Element!]! @relation(name: "ElementShared")
  name: String!
  element: Element! @relation(name: "SharedElement")
}

type Component {
  id: ID! @unique
  name: String! @unique
  creator: User! @relation(name: "UserComponents")
  props: [ComponentProp!]! @relation(name: "ComponentProps")
}

type ComponentProp {
  id: ID! @unique
  component: Component! @relation(name: "ComponentProps")
  name: String!
  type: PropType!
}

enum PropType {
  BOOLEAN
  NUMBER
  STRING
  VIEW_STYLE
  TEXT_STYLE
}

# We will have proper indexes to ensure unique name for element prop soon.
# https://github.com/prisma/prisma/issues/3405
type ElementProp {
  id: ID! @unique
  element: Element! @relation(name: "ElementProps")
  name: String!
  type: PropType!
  valueStyle: Style @relation(name: "StyleProp")
  value: String
}

# https://github.com/facebook/react-native/blob/master/Libraries/StyleSheet/StyleSheetTypes.js
type Style {
  id: ID! @unique
  web: Web! @relation(name: "WebStyles")
  props: [ElementProp!]! @relation(name: "StyleProp")
  name: String!
  # There are two kinds of style. Layout style and text style. Layout is for
  # View, text is for Text. Text has everything View has plus own props.
  isText: Boolean @default(value: "false")
  spreadStyles: [StyleSpread!]!
    @relation(name: "StyleSpreadStyles", onDelete: CASCADE)

  # View
  display: StyleDisplay
  width: DimensionValue @relation(name: "StyleWidth")
  height: DimensionValue @relation(name: "StyleHeight")
  bottom: DimensionValue @relation(name: "StyleBottom")
  end: DimensionValue @relation(name: "StyleEnd")
  left: DimensionValue @relation(name: "StyleLeft")
  right: DimensionValue @relation(name: "StyleRight")
  start: DimensionValue @relation(name: "StyleStart")
  top: DimensionValue @relation(name: "StyleTop")
  minWidth: DimensionValue @relation(name: "StyleMinWidth")
  maxWidth: DimensionValue @relation(name: "StyleMaxWidth")
  minHeight: DimensionValue @relation(name: "StyleMinHeight")
  maxHeight: DimensionValue @relation(name: "StyleMaxHeight")
  margin: DimensionValue @relation(name: "StyleMargin")
  marginBottom: DimensionValue @relation(name: "StyleMarginBottom")
  marginEnd: DimensionValue @relation(name: "StyleMarginEnd")
  marginHorizontal: DimensionValue @relation(name: "StyleMarginHorizontal")
  marginLeft: DimensionValue @relation(name: "StyleMarginLeft")
  marginRight: DimensionValue @relation(name: "StyleMarginRight")
  marginStart: DimensionValue @relation(name: "StyleMarginStart")
  marginTop: DimensionValue @relation(name: "StyleMarginTop")
  marginVertical: DimensionValue @relation(name: "StyleMarginVertical")
  padding: DimensionValue @relation(name: "StylePadding")
  paddingBottom: DimensionValue @relation(name: "StylePaddingBottom")
  paddingEnd: DimensionValue @relation(name: "StylePaddingEnd")
  paddingHorizontal: DimensionValue @relation(name: "StylePaddingHorizontal")
  paddingLeft: DimensionValue @relation(name: "StylePaddingLeft")
  paddingRight: DimensionValue @relation(name: "StylePaddingRight")
  paddingStart: DimensionValue @relation(name: "StylePaddingStart")
  paddingTop: DimensionValue @relation(name: "StylePaddingTop")
  paddingVertical: DimensionValue @relation(name: "StylePaddingVertical")
  position: StylePosition
  flexDirection: StyleFlexDirection
  flexWrap: StyleFlexWrap
  justifyContent: StyleJustifyContent
  alignItems: StyleAlignItems
  alignSelf: StyleAlignSelf
  alignContent: StyleAlignContent
  overflow: StyleOverflow
  flex: Int
  flexGrow: Int
  flexShrink: Int
  # flexBasis can be number or 'auto', but Prisma doesn't support union types
  # yet. Therefore, -1 is considered to be 'auto'.
  flexBasis: Int
  zIndex: Int
  direction: StyleDirection
  backgroundColor: ColorValue @relation(name: "StyleBackgroundColor")
  borderColor: ColorValue @relation(name: "StyleBorderColor")
  borderBottomColor: ColorValue @relation(name: "StyleBorderBottomColor")
  borderEndColor: ColorValue @relation(name: "StyleBorderEndColor")
  borderLeftColor: ColorValue @relation(name: "StyleBorderLeftColor")
  borderRightColor: ColorValue @relation(name: "StyleBorderRightColor")
  borderStartColor: ColorValue @relation(name: "StyleBorderStartColor")
  borderTopColor: ColorValue @relation(name: "StyleBorderTopColor")
  borderRadius: BorderValue @relation(name: "StyleBorderRadius")
  borderBottomEndRadius: BorderValue
    @relation(name: "StyleBorderBottomEndRadius")
  borderBottomLeftRadius: BorderValue
    @relation(name: "StyleBorderBottomLeftRadius")
  borderBottomRightRadius: BorderValue
    @relation(name: "StyleBorderBottomRightRadius")
  borderBottomStartRadius: BorderValue
    @relation(name: "StyleBorderBottomStartRadius")
  borderTopEndRadius: BorderValue @relation(name: "StyleBorderTopEndRadius")
  borderTopLeftRadius: BorderValue @relation(name: "StyleBorderTopLeftRadius")
  borderTopRightRadius: BorderValue @relation(name: "StyleBorderTopRightRadius")
  borderTopStartRadius: BorderValue @relation(name: "StyleBorderTopStartRadius")
  borderStyle: StyleBorderStyle
  borderWidth: BorderValue @relation(name: "StyleBorderWidth")
  borderBottomWidth: BorderValue @relation(name: "StyleBorderBottomWidth")
  borderEndWidth: BorderValue @relation(name: "StyleBorderEndWidth")
  borderLeftWidth: BorderValue @relation(name: "StyleBorderLeftWidth")
  borderRightWidth: BorderValue @relation(name: "StyleBorderRightWidth")
  borderStartWidth: BorderValue @relation(name: "StyleBorderStartWidth")
  borderTopWidth: BorderValue @relation(name: "StyleBorderTopWidth")
  opacity: Int
  # Text
  color: ColorValue @relation(name: "StyleColor")
  fontFamily: String
  fontSize: Int
  fontStyle: StyleFontStyle
  fontWeight: StyleFontWeight
  fontVariant: StyleFontVariant
  letterSpacing: Int
  lineHeight: Int
  textAlign: StyleTextAlign
  textAlignVertical: StyleTextAlignVertical
  textDecorationLine: StyleTextDecorationLine
  textTransform: StyleTextTransform

  # TODO: Add missing props.
}

# Spread styles like in JS (it is JS). Make bigger styles from smaller.
# Or override. Style composition over inheritance. Reactive CSS ftw.
# text -> heading, button => active button
# The point is, we can extends more styles.
# Classical inheritance: paragraph = { ...text, marginBottom: 24 }
# But what if we want to reuse marginBottom: 24 or something else?
# for marginBottom, we can use marginBottom: defaultBlockBottom constant.
# But what if we want to reuse more props? Then we are doomed. Or we can spread.
# paragraph = { ...text, marginBottom: 24 }
# Spread is useful for "utility classes" like .center, .whatever etc.
# https://adamwathan.me/css-utility-classes-and-separation-of-concerns/
# https://frontstuff.io/in-defense-of-utility-first-css
type StyleSpread {
  id: ID! @unique
  spreadStyle: Style! @relation(name: "StyleSpreadStyles")
  index: Int!
  style: Style! @relation(name: "SpreadStyle")
}

type DimensionValue {
  id: ID! @unique
  web: Web! @relation(name: "WebDimensionValues")
  name: String
  unit: DimensionValueUnit!
  value: Int!
}

enum DimensionValueUnit {
  POINT
  PERCENTAGE
  # 'auto' - value: 1
  KEYWORD
}

type ColorValue {
  id: ID! @unique
  web: Web! @relation(name: "WebColorValues")
  name: String
  r: Int!
  g: Int!
  b: Int!
  a: Float
}

type BorderValue {
  id: ID! @unique
  web: Web! @relation(name: "WebBorderValues")
  name: String
  unit: BorderValueUnit!
  value: Int!
}

enum BorderValueUnit {
  POINT
}

enum StyleDisplay {
  NONE
  FLEX
}

enum StylePosition {
  ABSOLUTE
  RELATIVE
}

enum StyleFlexDirection {
  ROW
  ROW_REVERSE
  COLUMN
  COLUMN_REVERSE
}

enum StyleFlexWrap {
  WRAP
  NOWRAP
  WRAP_REVERSE
}

enum StyleJustifyContent {
  FLEX_START
  FLEX_END
  CENTER
  SPACE_BETWEEN
  SPACE_AROUND
  SPACE_EVENLY
}

enum StyleAlignItems {
  FLEX_START
  FLEX_END
  CENTER
  STRETCH
  BASELINE
}

enum StyleAlignSelf {
  AUTO
  FLEX_START
  FLEX_END
  CENTER
  STRETCH
  BASELINE
}

enum StyleAlignContent {
  FLEX_START
  FLEX_END
  CENTER
  STRETCH
  SPACE_BETWEEN
  SPACE_AROUND
}

enum StyleOverflow {
  VISIBLE
  HIDDEN
  SCROLL
}

enum StyleDirection {
  INHERIT
  LTR
  RTL
}

enum StyleBorderStyle {
  SOLID
  DOTTED
  DASHED
}

enum StyleFontStyle {
  NORMAL
  ITALIC
}

enum StyleFontWeight {
  NORMAL
  BOLD
  # Integers must be prefixed to be valid GraphQL enum value.
  INT_100
  INT_200
  INT_300
  INT_400
  INT_500
  INT_600
  INT_700
  INT_800
  INT_900
}

enum StyleFontVariant {
  SMALL_CAPS
}

enum StyleTextAlign {
  AUTO
  LEFT
  RIGHT
  CENTER
  JUSTIFY
}

enum StyleTextAlignVertical {
  AUTO
  TOP
  BOTTOM
  CENTER
}

enum StyleTextDecorationLine {
  NONE
  UNDERLINE
  LINE_THROUGH
  UNDERLINE_LINE_THROUGH
}

enum StyleTextTransform {
  NONE
  CAPITALIZE
  UPPERCASE
  LOWERCASE
}
